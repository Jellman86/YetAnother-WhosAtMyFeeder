name: Build and Push Docker Images

on:
  push:
    branches: [dev]
    tags: ["v*"]
    paths-ignore:
      - "docs/**"
      - "**/*.md"
  workflow_dispatch:  # Allow manual trigger

env:
  REGISTRY: ghcr.io

jobs:
  test-backend:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install dependencies
        run: |
          cd backend
          pip install -r requirements.txt

      - name: Migration smoke test (fresh DB)
        run: |
          cd backend
          export DB_PATH=/tmp/ci-speciesid.db
          rm -f "$DB_PATH"
          python -m alembic upgrade head

      - name: Migration idempotency check
        run: |
          cd backend
          export DB_PATH=/tmp/ci-speciesid.db
          python -m alembic upgrade head

      - name: Migration downgrade/upgrade check
        run: |
          cd backend
          export DB_PATH=/tmp/ci-speciesid.db
          python -m alembic downgrade -1
          python -m alembic upgrade head

      - name: SQLite schema sanity checks (FKs + integrity)
        run: |
          cd backend
          export DB_PATH=/tmp/ci-speciesid.db
          python - <<'PY'
          import sqlite3
          import sys
          import os

          db_path = os.environ["DB_PATH"]
          conn = sqlite3.connect(db_path)
          try:
            conn.execute("PRAGMA foreign_keys=ON;")

            # Basic health checks
            fk_enabled = conn.execute("PRAGMA foreign_keys;").fetchone()[0]
            if fk_enabled != 1:
              print("foreign_keys pragma is not enabled")
              sys.exit(1)

            integrity = conn.execute("PRAGMA integrity_check;").fetchone()[0]
            if integrity != "ok":
              print("integrity_check failed:", integrity)
              sys.exit(1)

            # Detect FK violations (also catches many bad constraints)
            fk_violations = conn.execute("PRAGMA foreign_key_check;").fetchall()
            if fk_violations:
              print("foreign_key_check violations:", fk_violations[:20])
              sys.exit(1)

            # Regression guard: taxonomy_translations must NOT have an FK to taxonomy_cache.taxa_id
            # (it caused sqlite3.OperationalError: foreign key mismatch on upgraded DBs).
            fk_list = conn.execute("PRAGMA foreign_key_list(taxonomy_translations);").fetchall()
            if fk_list:
              print("taxonomy_translations has unexpected foreign keys:", fk_list)
              sys.exit(1)

            # Smoke-write: this would have thrown OperationalError with the old FK mismatch.
            conn.execute(
              "INSERT OR REPLACE INTO taxonomy_translations (taxa_id, language_code, common_name) VALUES (?, ?, ?)",
              (123456, "ru", "test-name"),
            )
            conn.commit()
          finally:
            conn.close()
          print("SQLite sanity checks OK:", db_path)
          PY

      - name: Backend startup/shutdown smoke test
        run: |
          cd backend
          python - <<'PY'
          import asyncio
          import os
          import tempfile
          from pathlib import Path

          temp_dir = tempfile.mkdtemp(prefix="yawamf_ci_startup_")
          os.environ["MEDIA_CACHE_DIR"] = str(Path(temp_dir) / "media_cache")
          os.environ["DATA_DIR"] = str(Path(temp_dir) / "data")
          os.environ["CONFIG_DIR"] = str(Path(temp_dir) / "config")
          os.environ["CONFIG_FILE"] = str(Path(temp_dir) / "config" / "config.json")
          os.environ["DB_PATH"] = str(Path(temp_dir) / "speciesid.db")

          Path(os.environ["MEDIA_CACHE_DIR"]).mkdir(parents=True, exist_ok=True)
          Path(os.environ["DATA_DIR"]).mkdir(parents=True, exist_ok=True)
          Path(os.environ["CONFIG_DIR"]).mkdir(parents=True, exist_ok=True)

          from app.main import app, lifespan

          async def smoke():
              async with lifespan(app):
                  assert hasattr(app.state, "startup_warnings")
                  assert isinstance(app.state.startup_warnings, list)

          asyncio.run(smoke())
          print("Startup/shutdown smoke test OK")
          PY

      - name: Run tests
        run: |
          cd backend
          python -m pytest tests/ -v --tb=short --cov=app --cov-report=term

      - name: Check minimum coverage
        run: |
          cd backend
          python -m pytest tests/ --cov=app --cov-fail-under=20

      - name: Ensure single Alembic head
        run: |
          cd backend
          python - <<'PY'
          import sys
          from alembic.config import Config
          from alembic.script import ScriptDirectory

          config = Config("alembic.ini")
          script = ScriptDirectory.from_config(config)
          heads = script.get_heads()
          if len(heads) != 1:
              print(f"Expected 1 Alembic head, found {len(heads)}: {heads}")
              sys.exit(1)
          print(f"Alembic head OK: {heads[0]}")
          PY

  test-frontend:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'
          cache: 'npm'
          cache-dependency-path: apps/ui/package-lock.json

      - name: Install dependencies
        run: |
          cd apps/ui
          npm ci

      - name: Svelte check
        run: |
          cd apps/ui
          npm run check

      - name: Build frontend
        run: |
          cd apps/ui
          npm run build

  build-backend:
    needs: test-backend
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set lowercase owner name
        run: echo "OWNER_LC=${GITHUB_REPOSITORY_OWNER,,}" >> $GITHUB_ENV

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Get version
        run: |
          if [[ "${{ github.ref }}" == refs/tags/v* ]]; then
            # Prefer tag version for releases (strip leading 'v')
            echo "APP_VERSION_BASE=${GITHUB_REF_NAME#v}" >> $GITHUB_ENV
          else
            echo "APP_VERSION_BASE=$(cat VERSION)" >> $GITHUB_ENV
          fi

      - name: Get branch and SHA
        run: |
          echo "SHORT_SHA=${GITHUB_SHA::7}" >> $GITHUB_ENV
          if [[ "${{ github.ref }}" == refs/tags/v* ]]; then
            # Avoid embedding tag name into APP_VERSION (it already encodes the version)
            echo "APP_BRANCH=main" >> $GITHUB_ENV
          else
            echo "APP_BRANCH=${GITHUB_REF_NAME}" >> $GITHUB_ENV
          fi

      - name: Determine image tag
        run: |
          if [[ "${{ github.ref }}" == refs/tags/v* ]]; then
            echo "IMAGE_TAG=${GITHUB_REF_NAME}" >> $GITHUB_ENV
            echo "PUBLISH_LATEST=true" >> $GITHUB_ENV
          else
            echo "IMAGE_TAG=dev" >> $GITHUB_ENV
            echo "PUBLISH_LATEST=false" >> $GITHUB_ENV
          fi

      - name: Build and push backend
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          push: true
          build-args: |
            GIT_HASH=${{ env.SHORT_SHA }}
            APP_VERSION_BASE=${{ env.APP_VERSION_BASE }}
            APP_BRANCH=${{ env.APP_BRANCH }}
          tags: |
            ghcr.io/${{ env.OWNER_LC }}/wamf-backend:${{ env.IMAGE_TAG }}
            ghcr.io/${{ env.OWNER_LC }}/wamf-backend:${{ github.sha }}
      - name: Tag backend latest
        if: env.PUBLISH_LATEST == 'true'
        run: |
          docker buildx imagetools create \
            -t ghcr.io/${{ env.OWNER_LC }}/wamf-backend:latest \
            ghcr.io/${{ env.OWNER_LC }}/wamf-backend:${{ env.IMAGE_TAG }}

  build-frontend:
    needs: test-frontend
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set lowercase owner name
        run: echo "OWNER_LC=${GITHUB_REPOSITORY_OWNER,,}" >> $GITHUB_ENV

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Get version
        run: |
          if [[ "${{ github.ref }}" == refs/tags/v* ]]; then
            # Prefer tag version for releases (strip leading 'v')
            echo "APP_VERSION_BASE=${GITHUB_REF_NAME#v}" >> $GITHUB_ENV
          else
            echo "APP_VERSION_BASE=$(cat VERSION)" >> $GITHUB_ENV
          fi

      - name: Get branch and SHA
        run: |
          echo "SHORT_SHA=${GITHUB_SHA::7}" >> $GITHUB_ENV
          if [[ "${{ github.ref }}" == refs/tags/v* ]]; then
            # Avoid embedding tag name into APP_VERSION (it already encodes the version)
            echo "APP_BRANCH=main" >> $GITHUB_ENV
          else
            echo "APP_BRANCH=${GITHUB_REF_NAME}" >> $GITHUB_ENV
          fi

      - name: Determine image tag
        run: |
          if [[ "${{ github.ref }}" == refs/tags/v* ]]; then
            echo "IMAGE_TAG=${GITHUB_REF_NAME}" >> $GITHUB_ENV
            echo "PUBLISH_LATEST=true" >> $GITHUB_ENV
          else
            echo "IMAGE_TAG=dev" >> $GITHUB_ENV
            echo "PUBLISH_LATEST=false" >> $GITHUB_ENV
          fi

      - name: Build and push frontend
        uses: docker/build-push-action@v5
        with:
          context: ./apps/ui
          push: true
          build-args: |
            GIT_HASH=${{ env.SHORT_SHA }}
            APP_VERSION_BASE=${{ env.APP_VERSION_BASE }}
            APP_BRANCH=${{ env.APP_BRANCH }}
          tags: |
            ghcr.io/${{ env.OWNER_LC }}/wamf-frontend:${{ env.IMAGE_TAG }}
            ghcr.io/${{ env.OWNER_LC }}/wamf-frontend:${{ github.sha }}
      - name: Tag frontend latest
        if: env.PUBLISH_LATEST == 'true'
        run: |
          docker buildx imagetools create \
            -t ghcr.io/${{ env.OWNER_LC }}/wamf-frontend:latest \
            ghcr.io/${{ env.OWNER_LC }}/wamf-frontend:${{ env.IMAGE_TAG }}
